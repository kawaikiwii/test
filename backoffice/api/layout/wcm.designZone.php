<?php

/**
 * The wcmDesignZone class
 * Used by the generator and defined by the drag and drop editor to save
 * the zone defined by the drag and drop layout.
 */

class wcmDesignZone implements wcmEnumerable 
{
	/**
	 * (int) Unique identifier
	 */
	public $id = 0;

	/**
	 * (string) Class of the source
	 */
	public $sourceClass = null;

	/**
	 * (int) Id of the source
	 */
	public $sourceId = 0;

	/**
	 * (string) Name of the zone
	 */
	public $zoneName = null;

	/**
	 * (string) Content of the zone 
	 */
	public $zoneContent = null;

	/**
	 * (Array) Zone content 
	 */
	private $zoneContentArray = array();


	/** Protected properties used for enumeration */
	protected $enumQuery = '';
	protected $enumResultSet  = null;
	protected $enumTotalCount = null;
	protected $database = null;
	protected $tableName = '#__design_zone'; 


	/**
	 * Constructor
	 *
	 * @param $sourceClass Source name of the zone
	 * @param $sourceId Source id of the zone
	 * @param $zoneName Name of the zone
	 * @param $zoneContent Content of the zone
	 */
	public function __construct($sourceClass = null, $sourceId = 0, $zoneName = null, $zoneContentArray = array())
	{
		$this->sourceClass = $sourceClass;
		$this->sourceId = $sourceId;
		$this->zoneName = $zoneName;
		$this->zoneContentArray = $zoneContentArray;


		$this->database = wcmProject::getInstance()->database;
	}

	/**
	 * This methods return the table name where to store designZones.
	 * This is used by the wcmDatabase.storeSysObject() method
	 * 
	 * @return string The table name where design zones are stored
	 */
	public function getTableName() 
	{
		return $this->tableName;    
	}

	/**
	 * Load or refresh a zone content
	 *
	 *	@param $fromDB	Boolean		Whether to refresh zone content from DB
	 *
	 *	@return	array of the current zone content
	 */
	public function refresh()
	{
			$project    = wcmProject::getInstance();

			$params = array($this->sourceClass, $this->sourceId, $this->zoneName);
			$query  = "SELECT zoneContent FROM " . $this->tableName ." WHERE sourceClass=? AND sourceId=? AND zoneName=?";

			$this->zoneContent = $project->database->executeScalar($query, $params);
			$this->zoneContentArray = unserialize($this->zoneContent);
		return $this->zoneContentArray;
	}

	/**
	 *	Save the current zone content in mem and in the database if require
	 *
	 *	@param $inDB	Boolean		Whether to commit zone content in the DB
	 */
	public function save()
	{
		$this->zoneContent = serialize($this->zoneContentArray);

			$project = wcmProject::getInstance();
			$this->delete();
			$project->database->storeSysObject($this);
	}


	/**
	 *	Replace the current zone content by the array given in parameters
	 *
	 *	@param $widgets Array	new widget array
	 */
	public function setWidgets($widgets) 
	{
		$this->zoneContentArray = $widgets;
	}

	/**
	 *	Add a widget at the bottom(end) of the current zone content
	 *
	 *	@param $widgetName 	String	Name of the widget
	 *	@param $settings	Array	Settings apply to the widget
	 */
	public function setWidget($widgetName, $widgetGuid, $settings = array())
	{
		$this->zoneContentArray[$widgetGuid] = array(
								'name' => $widgetName,
								'settings' => $settings
								);
	}

	public function addWidget($widgetName, $widgetGuid, $settings = array())
	{
		while(array_key_exists($widgetGuid, $this->zoneContentArray)) $widgetGuid++;
		$this->setWidget($widgetName, $widgetGuid, $settings);
	}

	/**
	 * return the getContent Array
	 */
	public function getZoneContent()
	{
		return $this->zoneContentArray;
	}

	public function setZoneContent($array)
	{
		$this->zoneContentArray = $array;
	}


	/**
	 *	Remove a widget from the content zone at a given position
	 *	
	 *	@param $position	Int 	Postion of the current widget (start at 0)
	 */
	public function removeWidget($position)
	{
		for( ; array_key_exists($position+1, $this->zoneContentArray) ; $position++)
				$this->zoneContentArray[$position] = $this->zoneContentArray[$position + 1];

		unset($this->zoneContentArray[$position]);
	}

	/**
	 *	Delete the current zone in memory and database
	 */
	public function	delete()
	{
			$project = wcmProject::getInstance();

			$params = array($this->sourceClass, $this->sourceId, $this->zoneName);
			$query = "DELETE FROM " . $this->tableName . " WHERE sourceClass=? AND sourceId=? AND zoneName=?";

			$project->database->executeStatement($query, $params);
	}

	/**
	 *	Return the bizObject generated by the sourceClass and the sourceId 
	 *
	 */
	public function getBizObject()
	{
		$project = wcmProject::getInstance();
		$className = $this->sourceClass;

		return $className($project, $this->sourceId);
	}

	/**
	 * Initialize and starts a new enumeration on current wcmSysobject
	 *
	 * @param string $where     Optional where clause
	 * @param string $orderby   Optional order clause
	 * @param int    $offset    Optional offset of first row (default is zero)
	 * @param int    $limit     Optional maximum number of returned rows (default is zero, means return all rows)
	 * @param string $of        Optional assoc Array with foreign constraint (key=className, value=id)
	 *
	 * @return boolean  True on success, false on failure
	 */
	public function beginEnum($where = null, $orderby = null, $offset = 0, $limit = 0, $of = null)
	{
		// Ensure to free previous enumeration
		$this->endEnum();

		// Extends where clause with "of" clause
		$ofClause = $this->ofClause($of);
		if ($ofClause != null)
		{
			if ($where != null && $where != '')
					$where = '('.$where.') AND '.$ofClause;
			else
					$where = $ofClause;
		}

		// First of all, compute total number of items
		if ($where == null || (strcmp($where, $this->enumQuery) != 0))
		{
			// Remember actual query
			$this->enumQuery = $where;

			// Compute number of wcmSysObject matching the query
			$sql = 'SELECT COUNT(*) FROM ' . $this->tableName;
			if ($where != null && $where != '')
					$sql .= ' WHERE '.$where;

			$this->enumTotalCount = $this->database->executeScalar($sql);
		}

		// Prepare sql query
		$sql = 'SELECT * FROM ' . $this->tableName;
		if ($where !== null && $where != '')
				$sql .= ' WHERE '.$where;
		if ($orderby != null)
				$sql .= ' ORDER BY '.$orderby;

		// Load resultset
		$this->enumResultSet = $this->database->executeQuery($sql, null, $offset, $limit);
		if ($this->enumResultSet == null)
		{
			$this->lastErrorMsg = $this->database->getErrorMsg();
			return false;
		}

		return true;
	}

	/**
	 * Moves to the next item of current enumeration
	 *
	 * @return boolean True if enumeration has succeed, false otherwise
	 */
	public function nextEnum()
	{
		if ($this->enumResultSet == null)
				return false;

		// Erase existing property
		$properties = getPublicProperties($this);
		foreach ($properties as $property => $value)
		{
			$this->$property = null;
		}

		if (!$this->enumResultSet->next())
		{
			// We have reach the end of the resultset
			$this->endEnum();
			return false;
		}

		// Bind current object to current resultset row
		bindArrayToObject($this->enumResultSet->getRow(), $this);

		$this->zoneContentArray = unserialize($this->zoneContent);

		return $this;
	}

	/**
	 * Stops current enumeration
	 */
	public function endEnum()
	{
		// Free resultset
		$this->enumResultSet = null;
		$this->enumQuery = null;
		$this->enumTotalCount = 0;
	}

	/**
	 * Returns the total number of objects which can be enumerated (regardless of the
	 * offset and limit parameters passed in the {@link beginEnum()} method)
	 *
	 * @return int Total number of enumerable objects
	 */
	public function enumCount()
	{
		return $this->enumTotalCount;
	}


	/**
     * Computes the sql where clause matching foreign constraints
     * => This method must be overloaded by child class
     *
     * @param string $of Assoc Array with foreign constrains (key=className, value=id)
     *
     * @return string Sql where clause matching "of" constraints or null
     */
    protected function ofClause($of)
    {
        if ($of == null || !is_array($of)) return null;

        $sql = null;
        foreach($of as $key => $value)
        {
		}
        return $sql;
    }
	
}

